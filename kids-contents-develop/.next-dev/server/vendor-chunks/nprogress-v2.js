"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/nprogress-v2";
exports.ids = ["vendor-chunks/nprogress-v2"];
exports.modules = {

/***/ "(ssr)/./node_modules/nprogress-v2/dist/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/nprogress-v2/dist/index.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NProgress: () => (/* binding */ NProgress)\n/* harmony export */ });\n// src/utils.ts\nfunction clamp(n, min, max) {\n  return Math.max(min, Math.min(n, max));\n}\nfunction toBarPerc(n, direction) {\n  if (direction === \"rtl\") return (1 - n) * 100;\n  return (-1 + n) * 100;\n}\nfunction css(element, properties, value) {\n  if (typeof properties === \"string\") {\n    if (value !== void 0) {\n      element.style[properties] = value;\n    }\n  } else {\n    for (const prop in properties) {\n      if (properties.hasOwnProperty(prop)) {\n        const val = properties[prop];\n        if (val !== void 0) {\n          element.style[prop] = val;\n        }\n      }\n    }\n  }\n}\nfunction addClass(element, name) {\n  element.classList.add(name);\n}\nfunction removeClass(element, name) {\n  element.classList.remove(name);\n}\nfunction removeElement(element) {\n  if (element && element.parentNode) {\n    element.parentNode.removeChild(element);\n  }\n}\n\n// src/progress.ts\nvar NProgress = class {\n  static settings = {\n    minimum: 0.08,\n    maximum: 1,\n    // If template is null, the user can insert their own template in the DOM.\n    template: `<div class=\"bar\" role=\"bar\"><div class=\"peg\"></div></div>\n               <div class=\"spinner\" role=\"spinner\"><div class=\"spinner-icon\"></div></div>`,\n    easing: \"linear\",\n    positionUsing: \"\",\n    speed: 200,\n    trickle: true,\n    trickleSpeed: 200,\n    showSpinner: true,\n    barSelector: '[role=\"bar\"]',\n    spinnerSelector: '[role=\"spinner\"]',\n    parent: \"body\",\n    direction: \"ltr\"\n  };\n  static status = null;\n  // Queue for animation functions\n  static pending = [];\n  static isPaused = false;\n  // Configure NProgress with new options\n  static configure(options) {\n    Object.assign(this.settings, options);\n    return this;\n  }\n  // Check if NProgress has started\n  static isStarted() {\n    return typeof this.status === \"number\";\n  }\n  /**\n   * Set the progress status.\n   * This method updates the progress status for every progress element present in the DOM.\n   * If a template is provided, it will create a new progress element if one does not already exist.\n   * If the template is null, it relies on user-inserted elements.\n   */\n  static set(n) {\n    if (this.isPaused) return this;\n    const started = this.isStarted();\n    n = clamp(n, this.settings.minimum, this.settings.maximum);\n    this.status = n === this.settings.maximum ? null : n;\n    const progressElements = this.render(!started);\n    const speed = this.settings.speed;\n    const ease = this.settings.easing;\n    progressElements.forEach((progress) => progress.offsetWidth);\n    this.queue((next) => {\n      progressElements.forEach((progress) => {\n        const bar = progress.querySelector(\n          this.settings.barSelector\n        );\n        css(bar, this.barPositionCSS({ n, speed, ease }));\n      });\n      if (n === this.settings.maximum) {\n        progressElements.forEach((progress) => {\n          css(progress, { transition: \"none\", opacity: \"1\" });\n          progress.offsetWidth;\n        });\n        setTimeout(() => {\n          progressElements.forEach((progress) => {\n            css(progress, {\n              transition: `all ${speed}ms ${ease}`,\n              opacity: \"0\"\n            });\n          });\n          setTimeout(() => {\n            progressElements.forEach((progress) => {\n              this.remove(progress);\n              if (this.settings.template === null) {\n                css(progress, { transition: \"none\", opacity: \"1\" });\n              }\n            });\n            next();\n          }, speed);\n        }, speed);\n      } else {\n        setTimeout(next, speed);\n      }\n    });\n    return this;\n  }\n  // Start the progress bar\n  static start() {\n    if (!this.status) this.set(0);\n    const work = () => {\n      if (this.isPaused) return;\n      setTimeout(() => {\n        if (!this.status) return;\n        this.trickle();\n        work();\n      }, this.settings.trickleSpeed);\n    };\n    if (this.settings.trickle) work();\n    return this;\n  }\n  // Complete the progress\n  static done(force) {\n    if (!force && !this.status) return this;\n    return this.inc(0.3 + 0.5 * Math.random()).set(1);\n  }\n  // Increment the progress\n  static inc(amount) {\n    if (this.isPaused) return this;\n    let n = this.status;\n    if (!n) {\n      return this.start();\n    } else if (n > 1) {\n      return this;\n    } else {\n      if (typeof amount !== \"number\") {\n        if (n >= 0 && n < 0.2) {\n          amount = 0.1;\n        } else if (n >= 0.2 && n < 0.5) {\n          amount = 0.04;\n        } else if (n >= 0.5 && n < 0.8) {\n          amount = 0.02;\n        } else if (n >= 0.8 && n < 0.99) {\n          amount = 5e-3;\n        } else {\n          amount = 0;\n        }\n      }\n      n = clamp(n + amount, 0, 0.994);\n      return this.set(n);\n    }\n  }\n  // Advance the progress (trickle)\n  static trickle() {\n    if (this.isPaused) return this;\n    return this.inc();\n  }\n  // Handle jQuery promises (for compatibility)\n  static promise($promise) {\n    if (!$promise || $promise.state() === \"resolved\") {\n      return this;\n    }\n    let initial = 0, current = 0;\n    if (current === 0) {\n      this.start();\n    }\n    initial++;\n    current++;\n    $promise.always(() => {\n      current--;\n      if (current === 0) {\n        initial = 0;\n        this.done();\n      } else {\n        this.set((initial - current) / initial);\n      }\n    });\n    return this;\n  }\n  /**\n   * Renders the NProgress component.\n   * If a template is provided, it will create a progress element if none exists in the parent.\n   * If the template is null, it relies on the user to insert their own elements marked with the \"nprogress\" class.\n   */\n  static render(fromStart = false) {\n    const parent = typeof this.settings.parent === \"string\" ? document.querySelector(this.settings.parent) : this.settings.parent;\n    let progressElements = parent ? Array.from(parent.querySelectorAll(\".nprogress\")) : [];\n    if (this.settings.template !== null && progressElements.length === 0) {\n      addClass(document.documentElement, \"nprogress-busy\");\n      const progress = document.createElement(\"div\");\n      addClass(progress, \"nprogress\");\n      progress.innerHTML = this.settings.template;\n      if (parent !== document.body) {\n        addClass(parent, \"nprogress-custom-parent\");\n      }\n      parent.appendChild(progress);\n      progressElements.push(progress);\n    }\n    progressElements.forEach((progress) => {\n      if (this.settings.template === null) {\n        progress.style.display = \"\";\n      }\n      addClass(document.documentElement, \"nprogress-busy\");\n      if (parent !== document.body) {\n        addClass(parent, \"nprogress-custom-parent\");\n      }\n      const bar = progress.querySelector(\n        this.settings.barSelector\n      );\n      const perc = fromStart ? toBarPerc(0, this.settings.direction) : toBarPerc(this.status || 0, this.settings.direction);\n      css(\n        bar,\n        this.barPositionCSS({\n          n: this.status || 0,\n          speed: this.settings.speed,\n          ease: this.settings.easing,\n          perc\n        })\n      );\n      if (!this.settings.showSpinner) {\n        const spinner = progress.querySelector(\n          this.settings.spinnerSelector\n        );\n        spinner && removeElement(spinner);\n      }\n    });\n    return progressElements;\n  }\n  /**\n   * Remove the progress element from the DOM.\n   * If a progress element is provided, only that element is removed;\n   * otherwise, all progress elements and associated classes are removed.\n   * For user-provided templates (when settings.template === null), the element\n   * is hidden instead of being removed.\n   */\n  static remove(progressElement) {\n    if (progressElement) {\n      if (this.settings.template === null) {\n        progressElement.style.display = \"none\";\n      } else {\n        removeElement(progressElement);\n      }\n    } else {\n      removeClass(document.documentElement, \"nprogress-busy\");\n      const parent = typeof this.settings.parent === \"string\" ? document.querySelectorAll(this.settings.parent) : [this.settings.parent];\n      parent.forEach((p) => {\n        removeClass(p, \"nprogress-custom-parent\");\n      });\n      const progresses = document.querySelectorAll(\".nprogress\");\n      progresses.forEach((progress) => {\n        const elem = progress;\n        if (this.settings.template === null) {\n          elem.style.display = \"none\";\n        } else {\n          removeElement(elem);\n        }\n      });\n    }\n  }\n  // Pause the progress\n  static pause() {\n    this.isPaused = true;\n    return this;\n  }\n  // Resume the progress\n  static resume() {\n    this.isPaused = false;\n    return this;\n  }\n  // Check if NProgress is rendered in the DOM\n  static isRendered() {\n    return document.querySelectorAll(\".nprogress\").length > 0;\n  }\n  // Determine the CSS positioning method to use\n  static getPositioningCSS() {\n    const bodyStyle = document.body.style;\n    const vendorPrefix = \"WebkitTransform\" in bodyStyle ? \"Webkit\" : \"MozTransform\" in bodyStyle ? \"Moz\" : \"msTransform\" in bodyStyle ? \"ms\" : \"OTransform\" in bodyStyle ? \"O\" : \"\";\n    if (`${vendorPrefix}Perspective` in bodyStyle) {\n      return \"translate3d\";\n    } else if (`${vendorPrefix}Transform` in bodyStyle) {\n      return \"translate\";\n    } else {\n      return \"margin\";\n    }\n  }\n  // Queue function for animations\n  static queue(fn) {\n    this.pending.push(fn);\n    if (this.pending.length === 1) this.next();\n  }\n  static next() {\n    const fn = this.pending.shift();\n    if (fn) fn(this.next.bind(this));\n  }\n  static initPositionUsing() {\n    if (this.settings.positionUsing === \"\") {\n      this.settings.positionUsing = this.getPositioningCSS();\n    }\n  }\n  // Compute the CSS for positioning the bar\n  static barPositionCSS({\n    n,\n    speed,\n    ease,\n    perc\n  }) {\n    this.initPositionUsing();\n    let barCSS = {};\n    const computedPerc = perc ?? toBarPerc(n, this.settings.direction);\n    if (this.settings.positionUsing === \"translate3d\") {\n      barCSS = {\n        transform: `translate3d(${computedPerc}%,0,0)`\n      };\n    } else if (this.settings.positionUsing === \"translate\") {\n      barCSS = {\n        transform: `translate(${computedPerc}%,0)`\n      };\n    } else if (this.settings.positionUsing === \"width\") {\n      barCSS = {\n        width: `${this.settings.direction === \"rtl\" ? 100 - computedPerc : computedPerc + 100}%`,\n        ...this.settings.direction === \"rtl\" ? { right: \"0\", left: \"auto\" } : {}\n      };\n    } else if (this.settings.positionUsing === \"margin\") {\n      barCSS = this.settings.direction === \"rtl\" ? { \"margin-left\": `${-computedPerc}%` } : { \"margin-right\": `${-computedPerc}%` };\n    }\n    barCSS.transition = `all ${speed}ms ${ease}`;\n    return barCSS;\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbnByb2dyZXNzLXYyL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZ0JBQWdCO0FBQ3ZELE9BQU87QUFDUDtBQUNBO0FBQ0EsMEJBQTBCLGtDQUFrQztBQUM1RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsTUFBTSxLQUFLLEtBQUs7QUFDakQ7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtDQUFrQztBQUNsRTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBLE1BQU0sWUFBWSxhQUFhO0FBQy9CO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxhQUFhO0FBQy9DO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0M7QUFDQSxNQUFNO0FBQ047QUFDQSxrQkFBa0IsNEVBQTRFO0FBQzlGLGlEQUFpRCwyQkFBMkI7QUFDNUU7QUFDQSxNQUFNO0FBQ04scURBQXFELGtCQUFrQixjQUFjLEtBQUssSUFBSSxtQkFBbUIsY0FBYztBQUMvSDtBQUNBLCtCQUErQixNQUFNLEtBQUssS0FBSztBQUMvQztBQUNBO0FBQ0E7QUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbW91c2luZXMvLi9ub2RlX21vZHVsZXMvbnByb2dyZXNzLXYyL2Rpc3QvaW5kZXgubWpzP2RmM2QiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3V0aWxzLnRzXG5mdW5jdGlvbiBjbGFtcChuLCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihuLCBtYXgpKTtcbn1cbmZ1bmN0aW9uIHRvQmFyUGVyYyhuLCBkaXJlY3Rpb24pIHtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gXCJydGxcIikgcmV0dXJuICgxIC0gbikgKiAxMDA7XG4gIHJldHVybiAoLTEgKyBuKSAqIDEwMDtcbn1cbmZ1bmN0aW9uIGNzcyhlbGVtZW50LCBwcm9wZXJ0aWVzLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIHByb3BlcnRpZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgZWxlbWVudC5zdHlsZVtwcm9wZXJ0aWVzXSA9IHZhbHVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcGVydGllcykge1xuICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgY29uc3QgdmFsID0gcHJvcGVydGllc1twcm9wXTtcbiAgICAgICAgaWYgKHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgbmFtZSkge1xuICBlbGVtZW50LmNsYXNzTGlzdC5hZGQobmFtZSk7XG59XG5mdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtZW50LCBuYW1lKSB7XG4gIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICBlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gIH1cbn1cblxuLy8gc3JjL3Byb2dyZXNzLnRzXG52YXIgTlByb2dyZXNzID0gY2xhc3Mge1xuICBzdGF0aWMgc2V0dGluZ3MgPSB7XG4gICAgbWluaW11bTogMC4wOCxcbiAgICBtYXhpbXVtOiAxLFxuICAgIC8vIElmIHRlbXBsYXRlIGlzIG51bGwsIHRoZSB1c2VyIGNhbiBpbnNlcnQgdGhlaXIgb3duIHRlbXBsYXRlIGluIHRoZSBET00uXG4gICAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwiYmFyXCIgcm9sZT1cImJhclwiPjxkaXYgY2xhc3M9XCJwZWdcIj48L2Rpdj48L2Rpdj5cbiAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzcGlubmVyXCIgcm9sZT1cInNwaW5uZXJcIj48ZGl2IGNsYXNzPVwic3Bpbm5lci1pY29uXCI+PC9kaXY+PC9kaXY+YCxcbiAgICBlYXNpbmc6IFwibGluZWFyXCIsXG4gICAgcG9zaXRpb25Vc2luZzogXCJcIixcbiAgICBzcGVlZDogMjAwLFxuICAgIHRyaWNrbGU6IHRydWUsXG4gICAgdHJpY2tsZVNwZWVkOiAyMDAsXG4gICAgc2hvd1NwaW5uZXI6IHRydWUsXG4gICAgYmFyU2VsZWN0b3I6ICdbcm9sZT1cImJhclwiXScsXG4gICAgc3Bpbm5lclNlbGVjdG9yOiAnW3JvbGU9XCJzcGlubmVyXCJdJyxcbiAgICBwYXJlbnQ6IFwiYm9keVwiLFxuICAgIGRpcmVjdGlvbjogXCJsdHJcIlxuICB9O1xuICBzdGF0aWMgc3RhdHVzID0gbnVsbDtcbiAgLy8gUXVldWUgZm9yIGFuaW1hdGlvbiBmdW5jdGlvbnNcbiAgc3RhdGljIHBlbmRpbmcgPSBbXTtcbiAgc3RhdGljIGlzUGF1c2VkID0gZmFsc2U7XG4gIC8vIENvbmZpZ3VyZSBOUHJvZ3Jlc3Mgd2l0aCBuZXcgb3B0aW9uc1xuICBzdGF0aWMgY29uZmlndXJlKG9wdGlvbnMpIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuc2V0dGluZ3MsIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8vIENoZWNrIGlmIE5Qcm9ncmVzcyBoYXMgc3RhcnRlZFxuICBzdGF0aWMgaXNTdGFydGVkKCkge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy5zdGF0dXMgPT09IFwibnVtYmVyXCI7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgcHJvZ3Jlc3Mgc3RhdHVzLlxuICAgKiBUaGlzIG1ldGhvZCB1cGRhdGVzIHRoZSBwcm9ncmVzcyBzdGF0dXMgZm9yIGV2ZXJ5IHByb2dyZXNzIGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgRE9NLlxuICAgKiBJZiBhIHRlbXBsYXRlIGlzIHByb3ZpZGVkLCBpdCB3aWxsIGNyZWF0ZSBhIG5ldyBwcm9ncmVzcyBlbGVtZW50IGlmIG9uZSBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgKiBJZiB0aGUgdGVtcGxhdGUgaXMgbnVsbCwgaXQgcmVsaWVzIG9uIHVzZXItaW5zZXJ0ZWQgZWxlbWVudHMuXG4gICAqL1xuICBzdGF0aWMgc2V0KG4pIHtcbiAgICBpZiAodGhpcy5pc1BhdXNlZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3Qgc3RhcnRlZCA9IHRoaXMuaXNTdGFydGVkKCk7XG4gICAgbiA9IGNsYW1wKG4sIHRoaXMuc2V0dGluZ3MubWluaW11bSwgdGhpcy5zZXR0aW5ncy5tYXhpbXVtKTtcbiAgICB0aGlzLnN0YXR1cyA9IG4gPT09IHRoaXMuc2V0dGluZ3MubWF4aW11bSA/IG51bGwgOiBuO1xuICAgIGNvbnN0IHByb2dyZXNzRWxlbWVudHMgPSB0aGlzLnJlbmRlcighc3RhcnRlZCk7XG4gICAgY29uc3Qgc3BlZWQgPSB0aGlzLnNldHRpbmdzLnNwZWVkO1xuICAgIGNvbnN0IGVhc2UgPSB0aGlzLnNldHRpbmdzLmVhc2luZztcbiAgICBwcm9ncmVzc0VsZW1lbnRzLmZvckVhY2goKHByb2dyZXNzKSA9PiBwcm9ncmVzcy5vZmZzZXRXaWR0aCk7XG4gICAgdGhpcy5xdWV1ZSgobmV4dCkgPT4ge1xuICAgICAgcHJvZ3Jlc3NFbGVtZW50cy5mb3JFYWNoKChwcm9ncmVzcykgPT4ge1xuICAgICAgICBjb25zdCBiYXIgPSBwcm9ncmVzcy5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgIHRoaXMuc2V0dGluZ3MuYmFyU2VsZWN0b3JcbiAgICAgICAgKTtcbiAgICAgICAgY3NzKGJhciwgdGhpcy5iYXJQb3NpdGlvbkNTUyh7IG4sIHNwZWVkLCBlYXNlIH0pKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKG4gPT09IHRoaXMuc2V0dGluZ3MubWF4aW11bSkge1xuICAgICAgICBwcm9ncmVzc0VsZW1lbnRzLmZvckVhY2goKHByb2dyZXNzKSA9PiB7XG4gICAgICAgICAgY3NzKHByb2dyZXNzLCB7IHRyYW5zaXRpb246IFwibm9uZVwiLCBvcGFjaXR5OiBcIjFcIiB9KTtcbiAgICAgICAgICBwcm9ncmVzcy5vZmZzZXRXaWR0aDtcbiAgICAgICAgfSk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHByb2dyZXNzRWxlbWVudHMuZm9yRWFjaCgocHJvZ3Jlc3MpID0+IHtcbiAgICAgICAgICAgIGNzcyhwcm9ncmVzcywge1xuICAgICAgICAgICAgICB0cmFuc2l0aW9uOiBgYWxsICR7c3BlZWR9bXMgJHtlYXNlfWAsXG4gICAgICAgICAgICAgIG9wYWNpdHk6IFwiMFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHByb2dyZXNzRWxlbWVudHMuZm9yRWFjaCgocHJvZ3Jlc3MpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5yZW1vdmUocHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy50ZW1wbGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNzcyhwcm9ncmVzcywgeyB0cmFuc2l0aW9uOiBcIm5vbmVcIiwgb3BhY2l0eTogXCIxXCIgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIH0sIHNwZWVkKTtcbiAgICAgICAgfSwgc3BlZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0VGltZW91dChuZXh0LCBzcGVlZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLy8gU3RhcnQgdGhlIHByb2dyZXNzIGJhclxuICBzdGF0aWMgc3RhcnQoKSB7XG4gICAgaWYgKCF0aGlzLnN0YXR1cykgdGhpcy5zZXQoMCk7XG4gICAgY29uc3Qgd29yayA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzUGF1c2VkKSByZXR1cm47XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXR1cykgcmV0dXJuO1xuICAgICAgICB0aGlzLnRyaWNrbGUoKTtcbiAgICAgICAgd29yaygpO1xuICAgICAgfSwgdGhpcy5zZXR0aW5ncy50cmlja2xlU3BlZWQpO1xuICAgIH07XG4gICAgaWYgKHRoaXMuc2V0dGluZ3MudHJpY2tsZSkgd29yaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8vIENvbXBsZXRlIHRoZSBwcm9ncmVzc1xuICBzdGF0aWMgZG9uZShmb3JjZSkge1xuICAgIGlmICghZm9yY2UgJiYgIXRoaXMuc3RhdHVzKSByZXR1cm4gdGhpcztcbiAgICByZXR1cm4gdGhpcy5pbmMoMC4zICsgMC41ICogTWF0aC5yYW5kb20oKSkuc2V0KDEpO1xuICB9XG4gIC8vIEluY3JlbWVudCB0aGUgcHJvZ3Jlc3NcbiAgc3RhdGljIGluYyhhbW91bnQpIHtcbiAgICBpZiAodGhpcy5pc1BhdXNlZCkgcmV0dXJuIHRoaXM7XG4gICAgbGV0IG4gPSB0aGlzLnN0YXR1cztcbiAgICBpZiAoIW4pIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXJ0KCk7XG4gICAgfSBlbHNlIGlmIChuID4gMSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgYW1vdW50ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGlmIChuID49IDAgJiYgbiA8IDAuMikge1xuICAgICAgICAgIGFtb3VudCA9IDAuMTtcbiAgICAgICAgfSBlbHNlIGlmIChuID49IDAuMiAmJiBuIDwgMC41KSB7XG4gICAgICAgICAgYW1vdW50ID0gMC4wNDtcbiAgICAgICAgfSBlbHNlIGlmIChuID49IDAuNSAmJiBuIDwgMC44KSB7XG4gICAgICAgICAgYW1vdW50ID0gMC4wMjtcbiAgICAgICAgfSBlbHNlIGlmIChuID49IDAuOCAmJiBuIDwgMC45OSkge1xuICAgICAgICAgIGFtb3VudCA9IDVlLTM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYW1vdW50ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbiA9IGNsYW1wKG4gKyBhbW91bnQsIDAsIDAuOTk0KTtcbiAgICAgIHJldHVybiB0aGlzLnNldChuKTtcbiAgICB9XG4gIH1cbiAgLy8gQWR2YW5jZSB0aGUgcHJvZ3Jlc3MgKHRyaWNrbGUpXG4gIHN0YXRpYyB0cmlja2xlKCkge1xuICAgIGlmICh0aGlzLmlzUGF1c2VkKSByZXR1cm4gdGhpcztcbiAgICByZXR1cm4gdGhpcy5pbmMoKTtcbiAgfVxuICAvLyBIYW5kbGUgalF1ZXJ5IHByb21pc2VzIChmb3IgY29tcGF0aWJpbGl0eSlcbiAgc3RhdGljIHByb21pc2UoJHByb21pc2UpIHtcbiAgICBpZiAoISRwcm9taXNlIHx8ICRwcm9taXNlLnN0YXRlKCkgPT09IFwicmVzb2x2ZWRcIikge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGxldCBpbml0aWFsID0gMCwgY3VycmVudCA9IDA7XG4gICAgaWYgKGN1cnJlbnQgPT09IDApIHtcbiAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICB9XG4gICAgaW5pdGlhbCsrO1xuICAgIGN1cnJlbnQrKztcbiAgICAkcHJvbWlzZS5hbHdheXMoKCkgPT4ge1xuICAgICAgY3VycmVudC0tO1xuICAgICAgaWYgKGN1cnJlbnQgPT09IDApIHtcbiAgICAgICAgaW5pdGlhbCA9IDA7XG4gICAgICAgIHRoaXMuZG9uZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXQoKGluaXRpYWwgLSBjdXJyZW50KSAvIGluaXRpYWwpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBOUHJvZ3Jlc3MgY29tcG9uZW50LlxuICAgKiBJZiBhIHRlbXBsYXRlIGlzIHByb3ZpZGVkLCBpdCB3aWxsIGNyZWF0ZSBhIHByb2dyZXNzIGVsZW1lbnQgaWYgbm9uZSBleGlzdHMgaW4gdGhlIHBhcmVudC5cbiAgICogSWYgdGhlIHRlbXBsYXRlIGlzIG51bGwsIGl0IHJlbGllcyBvbiB0aGUgdXNlciB0byBpbnNlcnQgdGhlaXIgb3duIGVsZW1lbnRzIG1hcmtlZCB3aXRoIHRoZSBcIm5wcm9ncmVzc1wiIGNsYXNzLlxuICAgKi9cbiAgc3RhdGljIHJlbmRlcihmcm9tU3RhcnQgPSBmYWxzZSkge1xuICAgIGNvbnN0IHBhcmVudCA9IHR5cGVvZiB0aGlzLnNldHRpbmdzLnBhcmVudCA9PT0gXCJzdHJpbmdcIiA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5zZXR0aW5ncy5wYXJlbnQpIDogdGhpcy5zZXR0aW5ncy5wYXJlbnQ7XG4gICAgbGV0IHByb2dyZXNzRWxlbWVudHMgPSBwYXJlbnQgPyBBcnJheS5mcm9tKHBhcmVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLm5wcm9ncmVzc1wiKSkgOiBbXTtcbiAgICBpZiAodGhpcy5zZXR0aW5ncy50ZW1wbGF0ZSAhPT0gbnVsbCAmJiBwcm9ncmVzc0VsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgYWRkQ2xhc3MoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBcIm5wcm9ncmVzcy1idXN5XCIpO1xuICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgYWRkQ2xhc3MocHJvZ3Jlc3MsIFwibnByb2dyZXNzXCIpO1xuICAgICAgcHJvZ3Jlc3MuaW5uZXJIVE1MID0gdGhpcy5zZXR0aW5ncy50ZW1wbGF0ZTtcbiAgICAgIGlmIChwYXJlbnQgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgYWRkQ2xhc3MocGFyZW50LCBcIm5wcm9ncmVzcy1jdXN0b20tcGFyZW50XCIpO1xuICAgICAgfVxuICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHByb2dyZXNzKTtcbiAgICAgIHByb2dyZXNzRWxlbWVudHMucHVzaChwcm9ncmVzcyk7XG4gICAgfVxuICAgIHByb2dyZXNzRWxlbWVudHMuZm9yRWFjaCgocHJvZ3Jlc3MpID0+IHtcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnRlbXBsYXRlID09PSBudWxsKSB7XG4gICAgICAgIHByb2dyZXNzLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgfVxuICAgICAgYWRkQ2xhc3MoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBcIm5wcm9ncmVzcy1idXN5XCIpO1xuICAgICAgaWYgKHBhcmVudCAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICBhZGRDbGFzcyhwYXJlbnQsIFwibnByb2dyZXNzLWN1c3RvbS1wYXJlbnRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBiYXIgPSBwcm9ncmVzcy5xdWVyeVNlbGVjdG9yKFxuICAgICAgICB0aGlzLnNldHRpbmdzLmJhclNlbGVjdG9yXG4gICAgICApO1xuICAgICAgY29uc3QgcGVyYyA9IGZyb21TdGFydCA/IHRvQmFyUGVyYygwLCB0aGlzLnNldHRpbmdzLmRpcmVjdGlvbikgOiB0b0JhclBlcmModGhpcy5zdGF0dXMgfHwgMCwgdGhpcy5zZXR0aW5ncy5kaXJlY3Rpb24pO1xuICAgICAgY3NzKFxuICAgICAgICBiYXIsXG4gICAgICAgIHRoaXMuYmFyUG9zaXRpb25DU1Moe1xuICAgICAgICAgIG46IHRoaXMuc3RhdHVzIHx8IDAsXG4gICAgICAgICAgc3BlZWQ6IHRoaXMuc2V0dGluZ3Muc3BlZWQsXG4gICAgICAgICAgZWFzZTogdGhpcy5zZXR0aW5ncy5lYXNpbmcsXG4gICAgICAgICAgcGVyY1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5zaG93U3Bpbm5lcikge1xuICAgICAgICBjb25zdCBzcGlubmVyID0gcHJvZ3Jlc3MucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICB0aGlzLnNldHRpbmdzLnNwaW5uZXJTZWxlY3RvclxuICAgICAgICApO1xuICAgICAgICBzcGlubmVyICYmIHJlbW92ZUVsZW1lbnQoc3Bpbm5lcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb2dyZXNzRWxlbWVudHM7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgcHJvZ3Jlc3MgZWxlbWVudCBmcm9tIHRoZSBET00uXG4gICAqIElmIGEgcHJvZ3Jlc3MgZWxlbWVudCBpcyBwcm92aWRlZCwgb25seSB0aGF0IGVsZW1lbnQgaXMgcmVtb3ZlZDtcbiAgICogb3RoZXJ3aXNlLCBhbGwgcHJvZ3Jlc3MgZWxlbWVudHMgYW5kIGFzc29jaWF0ZWQgY2xhc3NlcyBhcmUgcmVtb3ZlZC5cbiAgICogRm9yIHVzZXItcHJvdmlkZWQgdGVtcGxhdGVzICh3aGVuIHNldHRpbmdzLnRlbXBsYXRlID09PSBudWxsKSwgdGhlIGVsZW1lbnRcbiAgICogaXMgaGlkZGVuIGluc3RlYWQgb2YgYmVpbmcgcmVtb3ZlZC5cbiAgICovXG4gIHN0YXRpYyByZW1vdmUocHJvZ3Jlc3NFbGVtZW50KSB7XG4gICAgaWYgKHByb2dyZXNzRWxlbWVudCkge1xuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudGVtcGxhdGUgPT09IG51bGwpIHtcbiAgICAgICAgcHJvZ3Jlc3NFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZUVsZW1lbnQocHJvZ3Jlc3NFbGVtZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlQ2xhc3MoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBcIm5wcm9ncmVzcy1idXN5XCIpO1xuICAgICAgY29uc3QgcGFyZW50ID0gdHlwZW9mIHRoaXMuc2V0dGluZ3MucGFyZW50ID09PSBcInN0cmluZ1wiID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0aGlzLnNldHRpbmdzLnBhcmVudCkgOiBbdGhpcy5zZXR0aW5ncy5wYXJlbnRdO1xuICAgICAgcGFyZW50LmZvckVhY2goKHApID0+IHtcbiAgICAgICAgcmVtb3ZlQ2xhc3MocCwgXCJucHJvZ3Jlc3MtY3VzdG9tLXBhcmVudFwiKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcHJvZ3Jlc3NlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIubnByb2dyZXNzXCIpO1xuICAgICAgcHJvZ3Jlc3Nlcy5mb3JFYWNoKChwcm9ncmVzcykgPT4ge1xuICAgICAgICBjb25zdCBlbGVtID0gcHJvZ3Jlc3M7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnRlbXBsYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlRWxlbWVudChlbGVtKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8vIFBhdXNlIHRoZSBwcm9ncmVzc1xuICBzdGF0aWMgcGF1c2UoKSB7XG4gICAgdGhpcy5pc1BhdXNlZCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLy8gUmVzdW1lIHRoZSBwcm9ncmVzc1xuICBzdGF0aWMgcmVzdW1lKCkge1xuICAgIHRoaXMuaXNQYXVzZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvLyBDaGVjayBpZiBOUHJvZ3Jlc3MgaXMgcmVuZGVyZWQgaW4gdGhlIERPTVxuICBzdGF0aWMgaXNSZW5kZXJlZCgpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5ucHJvZ3Jlc3NcIikubGVuZ3RoID4gMDtcbiAgfVxuICAvLyBEZXRlcm1pbmUgdGhlIENTUyBwb3NpdGlvbmluZyBtZXRob2QgdG8gdXNlXG4gIHN0YXRpYyBnZXRQb3NpdGlvbmluZ0NTUygpIHtcbiAgICBjb25zdCBib2R5U3R5bGUgPSBkb2N1bWVudC5ib2R5LnN0eWxlO1xuICAgIGNvbnN0IHZlbmRvclByZWZpeCA9IFwiV2Via2l0VHJhbnNmb3JtXCIgaW4gYm9keVN0eWxlID8gXCJXZWJraXRcIiA6IFwiTW96VHJhbnNmb3JtXCIgaW4gYm9keVN0eWxlID8gXCJNb3pcIiA6IFwibXNUcmFuc2Zvcm1cIiBpbiBib2R5U3R5bGUgPyBcIm1zXCIgOiBcIk9UcmFuc2Zvcm1cIiBpbiBib2R5U3R5bGUgPyBcIk9cIiA6IFwiXCI7XG4gICAgaWYgKGAke3ZlbmRvclByZWZpeH1QZXJzcGVjdGl2ZWAgaW4gYm9keVN0eWxlKSB7XG4gICAgICByZXR1cm4gXCJ0cmFuc2xhdGUzZFwiO1xuICAgIH0gZWxzZSBpZiAoYCR7dmVuZG9yUHJlZml4fVRyYW5zZm9ybWAgaW4gYm9keVN0eWxlKSB7XG4gICAgICByZXR1cm4gXCJ0cmFuc2xhdGVcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwibWFyZ2luXCI7XG4gICAgfVxuICB9XG4gIC8vIFF1ZXVlIGZ1bmN0aW9uIGZvciBhbmltYXRpb25zXG4gIHN0YXRpYyBxdWV1ZShmbikge1xuICAgIHRoaXMucGVuZGluZy5wdXNoKGZuKTtcbiAgICBpZiAodGhpcy5wZW5kaW5nLmxlbmd0aCA9PT0gMSkgdGhpcy5uZXh0KCk7XG4gIH1cbiAgc3RhdGljIG5leHQoKSB7XG4gICAgY29uc3QgZm4gPSB0aGlzLnBlbmRpbmcuc2hpZnQoKTtcbiAgICBpZiAoZm4pIGZuKHRoaXMubmV4dC5iaW5kKHRoaXMpKTtcbiAgfVxuICBzdGF0aWMgaW5pdFBvc2l0aW9uVXNpbmcoKSB7XG4gICAgaWYgKHRoaXMuc2V0dGluZ3MucG9zaXRpb25Vc2luZyA9PT0gXCJcIikge1xuICAgICAgdGhpcy5zZXR0aW5ncy5wb3NpdGlvblVzaW5nID0gdGhpcy5nZXRQb3NpdGlvbmluZ0NTUygpO1xuICAgIH1cbiAgfVxuICAvLyBDb21wdXRlIHRoZSBDU1MgZm9yIHBvc2l0aW9uaW5nIHRoZSBiYXJcbiAgc3RhdGljIGJhclBvc2l0aW9uQ1NTKHtcbiAgICBuLFxuICAgIHNwZWVkLFxuICAgIGVhc2UsXG4gICAgcGVyY1xuICB9KSB7XG4gICAgdGhpcy5pbml0UG9zaXRpb25Vc2luZygpO1xuICAgIGxldCBiYXJDU1MgPSB7fTtcbiAgICBjb25zdCBjb21wdXRlZFBlcmMgPSBwZXJjID8/IHRvQmFyUGVyYyhuLCB0aGlzLnNldHRpbmdzLmRpcmVjdGlvbik7XG4gICAgaWYgKHRoaXMuc2V0dGluZ3MucG9zaXRpb25Vc2luZyA9PT0gXCJ0cmFuc2xhdGUzZFwiKSB7XG4gICAgICBiYXJDU1MgPSB7XG4gICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7Y29tcHV0ZWRQZXJjfSUsMCwwKWBcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0aGlzLnNldHRpbmdzLnBvc2l0aW9uVXNpbmcgPT09IFwidHJhbnNsYXRlXCIpIHtcbiAgICAgIGJhckNTUyA9IHtcbiAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7Y29tcHV0ZWRQZXJjfSUsMClgXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodGhpcy5zZXR0aW5ncy5wb3NpdGlvblVzaW5nID09PSBcIndpZHRoXCIpIHtcbiAgICAgIGJhckNTUyA9IHtcbiAgICAgICAgd2lkdGg6IGAke3RoaXMuc2V0dGluZ3MuZGlyZWN0aW9uID09PSBcInJ0bFwiID8gMTAwIC0gY29tcHV0ZWRQZXJjIDogY29tcHV0ZWRQZXJjICsgMTAwfSVgLFxuICAgICAgICAuLi50aGlzLnNldHRpbmdzLmRpcmVjdGlvbiA9PT0gXCJydGxcIiA/IHsgcmlnaHQ6IFwiMFwiLCBsZWZ0OiBcImF1dG9cIiB9IDoge31cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0aGlzLnNldHRpbmdzLnBvc2l0aW9uVXNpbmcgPT09IFwibWFyZ2luXCIpIHtcbiAgICAgIGJhckNTUyA9IHRoaXMuc2V0dGluZ3MuZGlyZWN0aW9uID09PSBcInJ0bFwiID8geyBcIm1hcmdpbi1sZWZ0XCI6IGAkey1jb21wdXRlZFBlcmN9JWAgfSA6IHsgXCJtYXJnaW4tcmlnaHRcIjogYCR7LWNvbXB1dGVkUGVyY30lYCB9O1xuICAgIH1cbiAgICBiYXJDU1MudHJhbnNpdGlvbiA9IGBhbGwgJHtzcGVlZH1tcyAke2Vhc2V9YDtcbiAgICByZXR1cm4gYmFyQ1NTO1xuICB9XG59O1xuZXhwb3J0IHtcbiAgTlByb2dyZXNzXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/nprogress-v2/dist/index.mjs\n");

/***/ })

};
;